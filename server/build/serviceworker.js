"use strict";
let precacheConfig = [["/index.html", "f4025ff9f3ea4a2ffa2e3a4c897ddbcd"], ["/static/css/main.d42defb7.css", "35627aa7294a39af423965097c4c5dc8"], ["/static/js/main.59f40dcb.js", "5fd6845d7bb0b7ae72eef057a5ae8712"]];

let cacheName = "sw-precache-v3-sw-precache-webpack-plugin-" + (self.registration ? self.registration.scope : "");
let apiCacheName = "sw-apicache-v3-" + (self.registration ? self.registration.scope : "");

//generated by react-script
function cleanResponse(t) {
    return t.redirected ? ("body" in t ? Promise.resolve(t.body) : t.blob()).then(function (e) {
        return new Response(e, {headers: t.headers, status: t.status, statusText: t.statusText})
    }) : Promise.resolve(t)
}

//generated by react-script
function createCacheKey(e, t, n, r) {
    let a = new URL(e);
    return r && a.pathname.match(r) || (a.search += (a.search ? "&" : "") + encodeURIComponent(t) + "=" + encodeURIComponent(n)), a.toString()
}

//generated by react-script
function stripIgnoredUrlParameters(e, n) {
    var t = new URL(e);
    return t.hash = "", t.search = t.search.slice(1).split("&").map(function (e) {
        return e.split("=")
    }).filter(function (t) {
        return n.every(function (e) {
            return !e.test(t[0])
        })
    }).map(function (e) {
        return e.join("=")
    }).join("&"), t.toString()
}

let hashParamName = "_sw-precache";
let urlsToCacheKeys = new Map(precacheConfig.map(function (e) {
    let t = e[0], n = e[1], r = new URL(t, self.location), a = createCacheKey(r, hashParamName, n, /\.\w{8}\./);
    return [r.toString(), a]
}));

//generated by react-script
function setOfCachedUrls(cache) {
    return cache.keys().then(function (e) {
        return e.map(function (e) {
            return e.url
        })
    }).then(function (e) {
        return new Set(e)
    })
}


//generated by react-script
self.addEventListener("install", function (event) {
    event.waitUntil(caches.open(cacheName).then(function (cache) {
        return setOfCachedUrls(cache).then(function (urls) {
            return Promise.all(Array.from(urlsToCacheKeys.values()).map(function (url) {
                if (!urls.has(url)) {
                    let req = new Request(url, {credentials: "same-origin"});
                    return fetch(req).then(function (res) {
                        if (!res.ok) {
                            throw new Error("Request for " + url + " returned a response with status " + res.status);
                        }
                        return cleanResponse(res).then(function (e) {
                            return cache.put(url, e)
                        })
                    })
                }
            }))
        })
    }).then(function () {
        //become active
        return self.skipWaiting()
    }))
});

//generated by react-script
self.addEventListener("activate", function (event) {
    let urls = new Set(urlsToCacheKeys.values());
    event.waitUntil(caches.open(cacheName).then(function (cache) {
        return cache.keys().then(function (keys) {
            return Promise.all(keys.map(function (entity) {
                if (!urls.has(entity.url)) {
                    return cache.delete(entity)
                }
            }))
        })
    }).then(function () {
        return self.clients.claim()
    }))
});

//We are changing this one
self.addEventListener("fetch", function (event) {
    console.log("service worker fetch");
    if ("GET" === event.request.method) {
        console.log(`GET >>>>>>>>>>>> ${event.request.url}`);
        const request = event;

        event.respondWith(caches.open(apiCacheName)
            .then(cache => cache.match(request))
            .then(matching => matching || fetch(request)));

        event.waitUntil(caches.open(apiCacheName)
            .then(cache => fetch(request)
                .then(response => cache.put(request, response))));

    }
});