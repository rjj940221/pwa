self.importScripts('idb.js');

let precacheConfig = [["/index.html", "474a3b525aaeaf33dc8a6e32db784d77"], ["/static/css/main.d42defb7.css", "35627aa7294a39af423965097c4c5dc8"], ["/static/js/main.51a0d2f3.js", "93649c6b095a6bde7386ebdf044754a8"], ["https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css", ""], ["https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css", ""]];

let cacheName = "sw-precache-v3-sw-precache-webpack-plugin-" + (self.registration ? self.registration.scope : "");
const ignoreUrlParametersMatching = [/^utm_/];

const dbPromise = idb.open('toDo', 1, upgradeDB => {
    if (!upgradeDB.objectStoreNames.contains('addItems')) {
        upgradeDB.createObjectStore('addItems', {keyPath: 'id'});
    }
    if (!upgradeDB.objectStoreNames.contains('updateItems')) {
        upgradeDB.createObjectStore('updateItems', {keyPath: 'id'});
    }
});

const addDirectoryIndex = function (e, t) {
    let nUrl = new URL(e);
    return "/" === nUrl.pathname.slice(-1) && (nUrl.pathname += t), nUrl.toString()
};
let apiCacheName = "sw-apicache-v3-" + (self.registration ? self.registration.scope : "");

//generated by react-script
function cleanResponse(t) {
    return t.redirected ? ("body" in t ? Promise.resolve(t.body) : t.blob()).then(function (e) {
        return new Response(e, {headers: t.headers, status: t.status, statusText: t.statusText})
    }) : Promise.resolve(t)
}

//generated by react-script
function createCacheKey(e, t, n, r) {
    let a = new URL(e);
    return r && a.pathname.match(r) || (a.search += (a.search ? "&" : "") + encodeURIComponent(t) + "=" + encodeURIComponent(n)), a.toString()
}

//generated by react-script
function stripIgnoredUrlParameters(e, n) {
    var t = new URL(e);
    return t.hash = "", t.search = t.search.slice(1).split("&").map(function (e) {
        return e.split("=")
    }).filter(function (t) {
        return n.every(function (e) {
            return !e.test(t[0])
        })
    }).map(function (e) {
        return e.join("=")
    }).join("&"), t.toString()
}

let hashParamName = "_sw-precache";
let urlsToCacheKeys = new Map(precacheConfig.map(function (e) {
    let t = e[0], n = e[1], r = new URL(t, self.location), a = createCacheKey(r, hashParamName, n, /\.\w{8}\./);
    return [r.toString(), a]
}));

//generated by react-script
function setOfCachedUrls(cache) {
    return cache.keys().then(function (e) {
        return e.map(function (e) {
            return e.url
        })
    }).then(function (e) {
        return new Set(e)
    })
}


//generated by react-script
self.addEventListener("install", function (event) {
    event.waitUntil(caches.open(cacheName).then(function (cache) {
        return setOfCachedUrls(cache).then(function (urls) {
            return Promise.all(Array.from(urlsToCacheKeys.values()).map(function (url) {
                if (!urls.has(url)) {
                    let req = new Request(url, {credentials: "same-origin"});
                    return fetch(req).then(function (res) {
                        if (!res.ok) {
                            throw new Error("Request for " + url + " returned a response with status " + res.status);
                        }
                        return cleanResponse(res).then(function (e) {
                            return cache.put(url, e)
                        })
                    })
                }
            }))
        })
    }).then(function () {
        //forcibly become active
        return self.skipWaiting()
    }))
});

//generated by react-script
self.addEventListener("activate", function (event) {
    let urls = new Set(urlsToCacheKeys.values());
    event.waitUntil(caches.open(cacheName).then(function (cache) {
        return cache.keys().then(function (keys) {
            return Promise.all(keys.map(function (entity) {
                if (!urls.has(entity.url)) {
                    return cache.delete(entity)
                }
            }))
        })
    }).then(function () {
        return self.clients.claim()
    }))
});

//We are changing this one
self.addEventListener("fetch", function (event) {
    console.log(`service worker fetch ${event.request.url}`);
    if ("GET" === event.request.method) {
        if (event.request.url.search(/localhost:4200\/(?:todo|user)/) === -1) {
            let placeHolder;
            let noParamUrl = stripIgnoredUrlParameters(event.request.url, ignoreUrlParametersMatching);
            let r = "index.html";
            (placeHolder = urlsToCacheKeys.has(noParamUrl)) || (noParamUrl = addDirectoryIndex(noParamUrl, r),
                placeHolder = urlsToCacheKeys.has(noParamUrl));
            let a = "/index.html";
            !placeHolder && "navigate" === event.request.mode && isPathWhitelisted(["^(?!\\/__).*"], event.request.url) && (noParamUrl = new URL(a, self.location).toString(), placeHolder = urlsToCacheKeys.has(noParamUrl));
            if (placeHolder) {
                event.respondWith(caches.open(cacheName).then(function (e) {
                    return e.match(urlsToCacheKeys.get(noParamUrl)).then(function (e) {
                        if (e) return e;
                        throw Error("The cached response that was expected is missing.")
                    })
                }).catch(function (e) {
                    console.warn('Couldn\'t serve response for "%s" from cache: %O', event.request.url, e);
                    return fetch(event.request);
                }))
            }
        } else {
            const request = event.request;

            let cachePromise = caches.open(apiCacheName)
                .then(cache => cache.match(request.url))
                .then(match => {
                    if (match) {
                        return match;
                    }
                });

            event.respondWith(fetch(request).then((res) => {
                if (res.ok) {
                    return res;
                }
                return cachePromise
            }).catch(() => cachePromise));

            event.waitUntil(caches.open(apiCacheName)
                .then(cache => fetch(request)
                    .then(response => {
                        if (response.ok) {
                            cache.put(request.url, response)
                        }
                    })).catch(() => {
                    console.warn("failed to update cache")
                })
            );

        }
    }
});

let itemsync = function (dataBase, endpoint, method) {
    return dbPromise.then(db => {
        return db.transaction(dataBase)
            .objectStore(dataBase).getAll();
    }).then(addToDos => {
        // Post the messages to the server
        let requests = addToDos.map((toDo) => {
            return new Promise((resolve, reject) => {
                let url = endpoint.clone();
                if(url === '/todo/update'){
                    url = `/todo/update/${toDo.id}`
                }
                fetch(url, {
                    method: method,
                    body: JSON.stringify(toDo),
                    headers: {
                        'content-type': 'application/json'
                    },
                    mode: 'cors',
                }).then(() => resolve({id: toDo.id}))
                    .catch(err => reject(err))
            })
        });
        return Promise.all(requests);
    }).then((sentToDos) => {
            // Success! Remove them from idb
            let delets = sentToDos.map((item) => {
                    console.log(item.id);
                    return dbPromise.then(db => {
                        const tx = db.transaction(dataBase, 'readwrite');
                        tx.objectStore(dataBase).delete(item.id);
                        return tx.complete;
                    })
                }
            );
            return Promise.all(delets);
        }
    ).catch(err => {
        console.warn(err);
        return err;
    });
};

//We are adding this one
self.addEventListener('sync', function (event) {
    switch(event.tag) {
        case 'add-item-tag':
            console.log("add sync event");
            event.waitUntil(itemsync('addItems', '/todo/add', 'POST'));
            break;
        case 'update-item-tag':
            console.log("update sync event");
            event.waitUntil(itemsync('updateItems', '/todo/update', 'PUT'));
            break;
    }
});